/*
Copyright (C) 2013  George Nicolaou <george[at]preaver.[dot]com>

This file is part of Icarus Disassembly Engine (iDisasm).

Icarus Disassembly Engine (iDisasm) is free software: you can redistribute it 
and/or modify it under the terms of the GNU Lesser General Public License as 
published by the Free Software Foundation, either version 3 of the License, 
or (at your option) any later version.

Icarus Disassembly Engine (iDisasm) is distributed in the hope that it will be 
useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General 
Public License for more details.

You should have received a copy of the GNU Lesser General Public License
along with Icarus Disassembly Engine (iDisasm).  If not, see 
<http://www.gnu.org/licenses/>.
*/

#include "intel.h"
#include "idisasm_internal.h"


INSTRUCTION_INFO sinstruction_info[] = {
	{ "AAA", DECIMAL_ARITHMETIC, "ASCII adjust after addition" },
	{ "AAD", DECIMAL_ARITHMETIC, "ASCII adjust before division" },
	{ "AAM", DECIMAL_ARITHMETIC, "ASCII adjust after multiplication" },
	{ "AAS", DECIMAL_ARITHMETIC, "ASCII adjust after subtraction" },
	{ "ADC", BINARY_ARITHMETIC, "Add with carry" },
	{ "ADD", BINARY_ARITHMETIC, "Integer add" },
	{ "ADDPD", SSE2_PACKED_ARITHMETIC, "Add packed double-precision floating-point values" },
	{ "ADDPS", SSE_PACKED_ARITHMETIC, "Add packed single-precision floating-point values" },
	{ "ADDSD", SSE2_PACKED_ARITHMETIC, "Add scalar double precision floating-point values" },
	{ "ADDSS", SSE_PACKED_ARITHMETIC, "Add scalar single-precision floating-point values" },
	{ "ADDSUBPD", SSE3_SIMD_FLOAT_PACKED_ADDSUB, "Performs double-precision addition on the second pair of quadwords, and double-precision subtraction on the first pair" },
	{ "ADDSUBPS", SSE3_SIMD_FLOAT_PACKED_ADDSUB, "Performs single-precision addition on the second and fourth pairs of 32-bit data elements within the operands; single-precision subtraction on the first and third pairs" },
	{ "AESDEC", SSE4_2_AESNIPCLMULQDQ, "Perform an AES decryption round using an 128-bit state and a round key" },
	{ "AESDECLAST", SSE4_2_AESNIPCLMULQDQ, "Perform the last AES decryption round using an 128-bit state and a round key" },
	{ "AESENC", SSE4_2_AESNIPCLMULQDQ, "Perform an AES encryption round using an 128-bit state and a round key" },
	{ "AESENCLAST", SSE4_2_AESNIPCLMULQDQ, "Perform the last AES encryption round using an 128-bit state and a round key" },
	{ "AESIMC", SSE4_2_AESNIPCLMULQDQ, "Perform an inverse mix column transformation primitive" },
	{ "AESKEYGENASSIST", SSE4_2_AESNIPCLMULQDQ, "Assist the creation of round keys with a key expansion schedule" },
	{ "AND", LOGICAL_ARITHMETIC, "Perform bitwise logical AND" },
	{ "ANDNPD", SSE2_LOGICAL, "Perform bitwise logical AND NOT of packed double-precision floating-point values" },
	{ "ANDNPS", SSE_LOGICAL, "Perform bitwise logical AND NOT of packed single-precision floating-point values" },
	{ "ANDPD", SSE2_LOGICAL, "Perform bitwise logical AND of packed double-precision floatingpoint values" },
	{ "ANDPS", SSE_LOGICAL, "Perform bitwise logical AND of packed single-precision floatingpoint values" },
	{ "ARPL", SYSTEM_INSTRUCTION, "Adjust requested privilege level" },
	{ "BLENDPD", SSE4_1_PACKED_BLENDING, "Conditionally copies specified double-precision floating-point data elements in the source operand to the corresponding data elements in the destination, using an immediate byte control." },
	{ "BLENDPS", SSE4_1_PACKED_BLENDING, "Conditionally copies specified single-precision floating-point data elements in the source operand to the corresponding data elements in the destination, using an immediate byte control." },
	{ "BLENDVPD", SSE4_1_PACKED_BLENDING, "Conditionally copies specified double-precision floating-point data elements in the source operand to the corresponding data elements in the destination, using an implied mask." },
	{ "BLENDVPS", SSE4_1_PACKED_BLENDING, "Conditionally copies specified single-precision floating-point data elements in the source operand to the corresponding data elements in the destination, using an implied mask." },
	{ "BOUND", CONTROL_TRANSFER, "Detect value out of range" },
	{ "BSF", BIT_BYTE, "Bit scan forward" },
	{ "BSR", BIT_BYTE, "Bit scan reverse" },
	{ "BSWAP", DATA_TRANSFER, "Byte swap" },
	{ "BT", BIT_BYTE, "Bit test" },
	{ "BTC", BIT_BYTE, "Bit test and complement" },
	{ "BTR", BIT_BYTE, "Bit test and reset" },
	{ "BTS", BIT_BYTE, "Bit test and set" },
	{ "CALL", CONTROL_TRANSFER, "Call procedure" },
	{ "CBW", DATA_TRANSFER, "Convert byte to word" },
	{ "CDQ", DATA_TRANSFER, "Convert doubleword to quadword" },
	{ "CDQE", MODE_64BIT, "Convert doubleword to quadword" },
	{ "CLC", CONTROL_FLAG, "Clear the carry flag" },
	{ "CLD", CONTROL_FLAG, "Clear the direction flag" },
	{ "CLFLUSH", SSE2_CACHEABILITY_CONTROL_ORDERING, "Flushes and invalidates a memory operand and its associated cache line from all levels of the processor’s cache hierarchy" },
	{ "CLI", CONTROL_FLAG, "Clear the interrupt flag" },
	{ "CLTS", SYSTEM_INSTRUCTION, "Clear the task-switched flag" },
	{ "CMC", CONTROL_FLAG, "Complement the carry flag" },
	{ "CMOVAE", DATA_TRANSFER, "Conditional move if above or equal" },
	{ "CMOVBE", DATA_TRANSFER, "Conditional move if below or equal" },
	{ "CMOVA", DATA_TRANSFER, "Conditional move if above" },
	{ "CMOVC", DATA_TRANSFER, "Conditional move if carry" },
	{ "CMOVE", DATA_TRANSFER, "Conditional move if equal" },
	{ "CMOVGE", DATA_TRANSFER, "Conditional move if greater or equal" },
	{ "CMOVLE", DATA_TRANSFER, "Conditional move if less or equal" },
	{ "CMOVNLE", DATA_TRANSFER, "Conditional move if not less or equal" },
	{ "CMOVNA", DATA_TRANSFER, "Conditional move if not above" },
	{ "CMOVNB", DATA_TRANSFER, "Conditional move if not below" },
	{ "CMOVNC", DATA_TRANSFER, "Conditional move if not carry" },
	{ "CMOVNE", DATA_TRANSFER, "Conditional move if not equal" },
	{ "CMOVNG", DATA_TRANSFER, "Conditional move if not greater" },
	{ "CMOVL", DATA_TRANSFER, "Conditional move if less" },
	{ "CMOVNL", DATA_TRANSFER, "Conditional move if not less" },
	{ "CMOVNO", DATA_TRANSFER, "Conditional move if not overflow" },
	{ "CMOVNP", DATA_TRANSFER, "Conditional move if not parity" },
	{ "CMOVNS", DATA_TRANSFER, "Conditional move if not sign (non-negative)" },
	{ "CMOVNZ", DATA_TRANSFER, "Conditional move if not zero" },
	{ "CMOVO", DATA_TRANSFER, "Conditional move if overflow" },
	{ "CMOVP", DATA_TRANSFER, "Conditional move if parity" },
	{ "CMOVPE", DATA_TRANSFER, "Conditional move if parity even" },
	{ "CMOVPO", DATA_TRANSFER, "Conditional move if parity odd" },
	{ "CMOVS", DATA_TRANSFER, "Conditional move if sign (negative)" },
	{ "CMOVZ", DATA_TRANSFER, "Conditional move if zero" },
	{ "CMP", BINARY_ARITHMETIC, "Compare" },
	{ "CMPPD", SSE2_COMPARE, "Compare packed double-precision floating-point values" },
	{ "CMPPS", SSE_COMPARISON, "Compare packed single-precision floating-point values" },
	{ "CMPS", STRING_INSTRUCTIONS, "Compare string" },
	{ "CMPSB", STRING_INSTRUCTIONS, "Compare byte string" },
	{ "CMPSD", STRING_INSTRUCTIONS, "Compare doubleword string" },
	{ "CMPSQ", MODE_64BIT, "Compare string operands" },
	{ "CMPSS", SSE_COMPARISON, "Compare scalar single-precision floating-point values" },
	{ "CMPSW", STRING_INSTRUCTIONS, "Compare word string" },
	{ "CMPXCHG", DATA_TRANSFER, "Compare and exchange" },
	{ "CMPXCHG16B", MODE_64BIT, "Compare RDX:RAX with m128" },
	{ "CMPXCHG8B", DATA_TRANSFER, "Compare and exchange 8 bytes" },
	{ "COMISD", SSE2_COMPARE, "Perform ordered comparison of scalar double-precision floatingpoint values and set flags in EFLAGS register" },
	{ "COMISS", SSE_COMPARISON, "Perform ordered comparison of scalar single-precision floatingpoint values and set flags in EFLAGS register" },
	{ "CPUID", MISC_INSTRUCTION, "Processor identification" },
	{ "CRC32", SSE4_2_APPLICATIONACCELERATOR, "Provides hardware acceleration to calculate cyclic redundancy checks for fast and efficient implementation of data integrity protocols." },
	{ "CVTDQ2PD", SSE2_CONVERSION, "Convert packed doubleword integers to packed double-precision floating-point values" },
	{ "CVTDQ2PS", SSE2_PACKED_SPFP, "Convert packed doubleword integers to packed single-precision floating-point values" },
	{ "CVTPD2DQ", SSE2_CONVERSION, "Convert packed double-precision floating-point values to packed doubleword integers" },
	{ "CVTPD2PI", SSE2_CONVERSION, "Convert packed double-precision floating-point values to packed doubleword integers." },
	{ "CVTPD2PS", SSE2_CONVERSION, "Convert packed double-precision floating-point values to packed single-precision floating-point values" },
	{ "CVTPI2PD", SSE2_CONVERSION, "Convert packed doubleword integers to packed double-precision floating-point values" },
	{ "CVTPI2PS", SSE_CONVERSION, "Convert packed doubleword integers to packed single-precision floating-point values" },
	{ "CVTPS2DQ", SSE2_PACKED_SPFP, "Convert packed single-precision floating-point values to packed doubleword integers" },
	{ "CVTPS2PD", SSE2_CONVERSION, "Convert packed single-precision floating-point values to packed double-precision floating-point values" },
	{ "CVTPS2PI", SSE_CONVERSION, "Convert packed single-precision floating-point values to packed doubleword integers" },
	{ "CVTSD2SI", SSE2_CONVERSION, "Convert scalar double-precision floating-point values to a doubleword integer" },
	{ "CVTSD2SS", SSE2_CONVERSION, "Convert scalar double-precision floating-point values to scalar single-precision floating-point values" },
	{ "CVTSI2SD", SSE2_CONVERSION, "Convert doubleword integer to scalar double-precision floatingpoint value" },
	{ "CVTSI2SS", SSE_CONVERSION, "Convert doubleword integer to scalar single-precision floatingpoint value" },
	{ "CVTSS2SD", SSE2_CONVERSION, "Convert scalar single-precision floating-point values to scalar double-precision floating-point values" },
	{ "CVTSS2SI", SSE_CONVERSION, "Convert a scalar single-precision floating-point value to a doubleword integer" },
	{ "CVTTPD2DQ", SSE2_CONVERSION, "Convert with truncation packed double-precision floating-point values to packed doubleword integers" },
	{ "CVTTPD2PI", SSE2_CONVERSION, "Convert with truncation packed double-precision floating-point values to packed doubleword integers" },
	{ "CVTTPS2DQ", SSE2_PACKED_SPFP, "Convert with truncation packed single-precision floating-point values to packed doubleword integers" },
	{ "CVTTPS2PI", SSE_CONVERSION, "Convert with truncation packed single-precision floating-point values to packed doubleword integers" },
	{ "CVTTSD2SI", SSE2_CONVERSION, "Convert with truncation scalar double-precision floating-point values to scalar doubleword integers" },
	{ "CVTTSS2SI", SSE_CONVERSION, "Convert with truncation a scalar single-precision floating-point value to a scalar doubleword integer" },
	{ "CWD", DATA_TRANSFER, "Convert word to doubleword " },
	{ "CWDE", DATA_TRANSFER, "Convert word to doubleword in EAX register" },
	{ "DAA", DECIMAL_ARITHMETIC, "Decimal adjust after addition" },
	{ "DAS", DECIMAL_ARITHMETIC, "Decimal adjust after subtraction" },
	{ "DEC", BINARY_ARITHMETIC, "Decrement" },
	{ "DIV", BINARY_ARITHMETIC, "Unsigned divide" },
	{ "DIVPD", SSE2_PACKED_ARITHMETIC, "Divide packed double-precision floating-point values" },
	{ "DIVPS", SSE_PACKED_ARITHMETIC, "Divide packed single-precision floating-point values" },
	{ "DIVSD", SSE2_PACKED_ARITHMETIC, "Divide scalar double-precision floating-point values" },
	{ "DIVSS", SSE_PACKED_ARITHMETIC, "Divide scalar single-precision floating-point values" },
	{ "DPPD", SSE4_1_FP_DOTPRODUCT, "Perform double-precision dot product for up to 2 elements and broadcast." },
	{ "DPPS", SSE4_1_FP_DOTPRODUCT, "Perform single-precision dot products for up to 4 elements and broadcast" },
	{ "EMMS", MMX_STATE_MANAGEMENT, "Empty MMX state" },
	{ "ENTER", CONTROL_TRANSFER, "High-level procedure entry" },
	{ "EXTRACTPS", SSE4_1_INSERTION_EXTRACTION_MMX, "Extracts a single-precision floating-point value from a specified offset in an XMM register and stores the result to memory or a general-purpose register" },
	{ "F2XM1", FPU_TRANSCENDENTAL, "2x - 1" },
	{ "FABS", FPU_ARITHMETIC, "Absolute value" },
	{ "FADD", FPU_ARITHMETIC, "Add floating-point" },
	{ "FADDP", FPU_ARITHMETIC, "Add floating-point and pop" },
	{ "FBLD", FPU_DATA_TRANSFER, "Load BCD" },
	{ "FBSTP", FPU_DATA_TRANSFER, "Store BCD and pop" },
	{ "FCHS", FPU_ARITHMETIC, "Change sign" },
	{ "FCLEX", FPU_CONTROL, "Clear floating-point exception flags after checking for error conditions" },
	{ "FCMOVB", FPU_DATA_TRANSFER, "Floating-point conditional move if below" },
	{ "FCMOVBE", FPU_DATA_TRANSFER, "Floating-point conditional move if below or equal" },
	{ "FCMOVE", FPU_DATA_TRANSFER, "Floating-point conditional move if equal" },
	{ "FCMOVNB", FPU_DATA_TRANSFER, "Floating-point conditional move if not below" },
	{ "FCMOVNBE", FPU_DATA_TRANSFER, "Floating-point conditional move if not below or equal" },
	{ "FCMOVNE", FPU_DATA_TRANSFER, "Floating-point conditional move if not equal" },
	{ "FCMOVNU", FPU_DATA_TRANSFER, "Floating-point conditional move if not unordered" },
	{ "FCMOVU", FPU_DATA_TRANSFER, "Floating-point conditional move if unordered" },
	{ "FCOM", FPU_COMPARISON, "Compare floating-point" },
	{ "FCOMI", FPU_COMPARISON, "Compare floating-point and set EFLAGS" },
	{ "FCOMIP", FPU_COMPARISON, "Compare floating-point, set EFLAGS, and pop" },
	{ "FCOMP", FPU_COMPARISON, "Compare floating-point and pop" },
	{ "FCOMPP", FPU_COMPARISON, "Compare floating-point and pop twice" },
	{ "FCOS", FPU_TRANSCENDENTAL, "Cosine" },
	{ "FDECSTP", FPU_CONTROL, "Decrement FPU register stack pointer" },
	{ "FDIV", FPU_ARITHMETIC, "Divide floating-point" },
	{ "FDIVP", FPU_ARITHMETIC, "Divide floating-point and pop" },
	{ "FDIVR", FPU_ARITHMETIC, "Divide floating-point reverse" },
	{ "FDIVRP", FPU_ARITHMETIC, "Divide floating-point reverse and pop" },
	{ "FFREE", FPU_CONTROL, "Free floating-point register" },
	{ "FIADD", FPU_ARITHMETIC, "Add integer" },
	{ "FICOM", FPU_COMPARISON, "Compare integer" },
	{ "FICOMP", FPU_COMPARISON, "Compare integer and pop" },
	{ "FIDIV", FPU_ARITHMETIC, "Divide integer" },
	{ "FIDIVR", FPU_ARITHMETIC, "Divide integer reverse" },
	{ "FILD", FPU_DATA_TRANSFER, "Load integer" },
	{ "FIMUL", FPU_ARITHMETIC, "Multiply integer" },
	{ "FINCSTP", FPU_CONTROL, "Increment FPU register stack pointer" },
	{ "FINIT", FPU_CONTROL, "Initialize FPU after checking error conditions" },
	{ "FIST", FPU_DATA_TRANSFER, "Store integer" },
	{ "FISTP", FPU_DATA_TRANSFER, "Store integer and pop" },
	{ "FISTTP", SSE3_INTEGER_CONVERSION, "Behaves like the FISTP instruction but uses truncation, irrespective of the rounding mode specified in the floating-point control word (FCW)" },
	{ "FISUB", FPU_ARITHMETIC, "Subtract integer" },
	{ "FISUBR", FPU_ARITHMETIC, "Subtract integer reverse" },
	{ "FLD", FPU_DATA_TRANSFER, "Load floating-point value" },
	{ "FLD1", FPU_LOAD_CONSTANT, "Load +1.0" },
	{ "FLDCW", FPU_CONTROL, "Load FPU control word" },
	{ "FLDENV", FPU_CONTROL, "Load FPU environment" },
	{ "FLDL2E", FPU_LOAD_CONSTANT, "Load log2e" },
	{ "FLDL2T", FPU_LOAD_CONSTANT, "Load log210" },
	{ "FLDLG2", FPU_LOAD_CONSTANT, "Load log102" },
	{ "FLDLN2", FPU_LOAD_CONSTANT, "Load loge2" },
	{ "FLDPI", FPU_LOAD_CONSTANT, "Load p" },
	{ "FLDZ", FPU_LOAD_CONSTANT, "Load +0.0" },
	{ "FMUL", FPU_ARITHMETIC, "Multiply floating-point" },
	{ "FMULP", FPU_ARITHMETIC, "Multiply floating-point and pop" },
	{ "FNCLEX", FPU_CONTROL, "Clear floating-point exception flags without checking for error conditions" },
	{ "FNINIT", FPU_CONTROL, "Initialize FPU without checking error conditions" },
	{ "FNOP", FPU_CONTROL, "FPU no operation" },
	{ "FNSAVE", FPU_CONTROL, "Save FPU state without checking error conditions" },
	{ "FNSTCW", FPU_CONTROL, "Store FPU control word without checking error conditions" },
	{ "FNSTENV", FPU_CONTROL, "Store FPU environment without checking error conditions" },
	{ "FNSTSW", FPU_CONTROL, "Store FPU status word without checking error conditions" },
	{ "FPATAN", FPU_TRANSCENDENTAL, "Partial arctangent" },
	{ "FPREM", FPU_ARITHMETIC, "Partial remainder" },
	{ "FPREM1", FPU_ARITHMETIC, "IEEE Partial remainder" },
	{ "FPTAN", FPU_TRANSCENDENTAL, "Partial tangent" },
	{ "FRNDINT", FPU_ARITHMETIC, "Round to integer" },
	{ "FRSTOR", FPU_CONTROL, "Restore FPU state" },
	{ "FSAVE", FPU_CONTROL, "Save FPU state after checking error conditions" },
	{ "FSCALE", FPU_ARITHMETIC, "Scale by power of two" },
	{ "FSIN", FPU_TRANSCENDENTAL, "Sine" },
	{ "FSINCOS", FPU_TRANSCENDENTAL, "Sine and cosine" },
	{ "FSQRT", FPU_ARITHMETIC, "Square root" },
	{ "FST", FPU_DATA_TRANSFER, "Store floating-point value" },
	{ "FSTCW", FPU_CONTROL, "Store FPU control word after checking error conditions" },
	{ "FSTENV", FPU_CONTROL, "Store FPU environment after checking error conditions" },
	{ "FSTP", FPU_DATA_TRANSFER, "Store floating-point value and pop" },
	{ "FSTSW", FPU_CONTROL, "Store FPU status word after checking error conditions" },
	{ "FSUB", FPU_ARITHMETIC, "Subtract floating-point" },
	{ "FSUBP", FPU_ARITHMETIC, "Subtract floating-point and pop" },
	{ "FSUBR", FPU_ARITHMETIC, "Subtract floating-point reverse" },
	{ "FSUBRP", FPU_ARITHMETIC, "Subtract floating-point reverse and pop" },
	{ "FTST", FPU_COMPARISON, "Test floating-point (compare with 0.0)" },
	{ "FUCOM", FPU_COMPARISON, "Unordered compare floating-point" },
	{ "FUCOMI", FPU_COMPARISON, "Unordered compare floating-point and set EFLAGS" },
	{ "FUCOMIP", FPU_COMPARISON, "Unordered compare floating-point, set EFLAGS, and pop" },
	{ "FUCOMP", FPU_COMPARISON, "Unordered compare floating-point and pop" },
	{ "FUCOMPP", FPU_COMPARISON, "Unordered compare floating-point and pop twice" },
	{ "FWAIT", FPU_CONTROL, "Wait for FPU" },
	{ "FXAM", FPU_COMPARISON, "Examine floating-point" },
	{ "FXCH", FPU_DATA_TRANSFER, "Exchange registers" },
	{ "FXRSTOR", FPU_SIMD_STATE_MANAGEMENT, "Restore x87 FPU and SIMD state" },
	{ "FXSAVE", FPU_SIMD_STATE_MANAGEMENT, "Save x87 FPU and SIMD state" },
	{ "FXTRACT", FPU_ARITHMETIC, "Extract exponent and significant" },
	{ "FYL2X", FPU_TRANSCENDENTAL, "y*log2x" },
	{ "FYL2XP1", FPU_TRANSCENDENTAL, "y*log2(x+1)" },
	{ "GETSEC", SAFER_MODE_SMX, "GETSEC functions family executed based on EAX value" },
	{ "GETSEC[CAPABILITIES]", SAFER_MODE_SMX, "Returns the available leaf functions of the GETSEC instruction." },
	{ "GETSEC[ENTERACCS]", SAFER_MODE_SMX, "Loads an authenticated code chipset module and enters authenticated code execution mode." },
	{ "GETSEC[EXITAC]", SAFER_MODE_SMX, "Exits authenticated code execution mode." },
	{ "GETSEC[PARAMETERS]", SAFER_MODE_SMX, "Returns SMX related parameter information." },
	{ "GETSEC[SENTER]", SAFER_MODE_SMX, "Establishes a Measured Launched Environment (MLE) which has its dynamic root of trust anchored to a chipset supporting Intel Trusted Execution Technology." },
	{ "GETSEC[SEXIT]", SAFER_MODE_SMX, "Exits the MLE." },
	{ "GETSEC[SMCTRL]", SAFER_MODE_SMX, "SMX mode control." },
	{ "GETSEC[WAKEUP]", SAFER_MODE_SMX, "Wakes up sleeping logical processors inside an MLE." },
	{ "HADDPD", SSE3_SIMD_FLOAT_HORIZONTAL_ADDSUB, "Performs a double-precision addition on contiguous data elements. The first data element of the result is obtained by adding the first and second elements of the first operand; the second element by adding the first and second elements of the second operand." },
	{ "HADDPS", SSE3_SIMD_FLOAT_HORIZONTAL_ADDSUB, "Performs a single-precision addition on contiguous data elements. The first data element of the result is obtained by adding the first and second elements of the first operand; the second element by adding the third and fourth elements of the first operand; the third by adding the first and second elements of the second operand; and the fourth by adding the third and fourth elements of the second operand." },
	{ "HLT", SYSTEM_INSTRUCTION, "Halt processor" },
	{ "HSUBPD", SSE3_SIMD_FLOAT_HORIZONTAL_ADDSUB, "Performs a double-precision subtraction on contiguous data elements. The first data element of the result is obtained by subtracting the second element of the first operand from the first element of the first operand; the second element by subtracting the second element of the second operand from the first element of the second operand." },
	{ "HSUBPS", SSE3_SIMD_FLOAT_HORIZONTAL_ADDSUB, "Performs a single-precision subtraction on contiguous data elements. The first data element of the result is obtained by subtracting the second element of the first operand from the first element of the first operand; the second element by subtracting the fourth element of the first operand from the third element of the first operand; the third by subtracting the second element of the second operand from the first element of the second operand; and the fourth by subtracting the fourth element of the second operand from the third element of the second operand." },
	{ "IDIV", BINARY_ARITHMETIC, "Signed divide" },
	{ "IMUL", BINARY_ARITHMETIC, "Signed multiply" },
	{ "IN", IO_INSTRUCTION, "Read from a port" },
	{ "INC", BINARY_ARITHMETIC, "Increment" },
	{ "INS", IO_INSTRUCTION, "Input string from port" },
	{ "INSB", IO_INSTRUCTION, "Input byte string from port" },
	{ "INSD", IO_INSTRUCTION, "Input doubleword string from port" },
	{ "INSERTPS", SSE4_1_INSERTION_EXTRACTION_MMX, "Inserts a single-precision floating-point value from either a 32- bit memory location or selected from a specified offset in an XMM register to a specified offset in the destination XMM register. In addition, INSERTPS allows zeroing out selected data elements in the destination, using a mask." },
	{ "INSW", IO_INSTRUCTION, "Input word string from port" },
	{ "INT1", CONTROL_TRANSFER, "ICEBP Interrupt" },
	{ "INT3", CONTROL_TRANSFER, "Software breakpoint interrupt" },
	{ "INT", CONTROL_TRANSFER, "Software interrupt" },
	{ "INTO", CONTROL_TRANSFER, "Interrupt on overflow" },
	{ "INVD", SYSTEM_INSTRUCTION, "Invalidate cache, no writeback" },
	{ "INVEPT", VM_EXTENSIONS, "Invalidate cached Extended Page Table (EPT) mappings in the processor to synchronize address translation in virtual machines with memory-resident EPT pages." },
	{ "INVLPG", SYSTEM_INSTRUCTION, "Invalidate TLB Entry" },
	{ "INVPCID", SYSTEM_INSTRUCTION, "Invalidate Process-Context Identifier" },
	{ "INVVPID", VM_EXTENSIONS, "Invalidate cached mappings of address translation based on the Virtual Processor ID (VPID)." },
	{ "IRET", CONTROL_TRANSFER, "Return from interrupt" },
	{ "JA", CONTROL_TRANSFER, "Jump if above" },
	{ "JAE", CONTROL_TRANSFER, "Jump if above or equal" },
	{ "JB", CONTROL_TRANSFER, "Jump if below" },
	{ "JBE", CONTROL_TRANSFER, "Jump if below or equal" },
	{ "JC", CONTROL_TRANSFER, "Jump if carry" },
	{ "JCXZ", CONTROL_TRANSFER, "Jump register CX zero" },
	{ "JE", CONTROL_TRANSFER, "Jump if equal" },
	{ "JECXZ", CONTROL_TRANSFER, "Jump register ECX zero" },
	{ "JG", CONTROL_TRANSFER, "Jump if greater" },
	{ "JGE", CONTROL_TRANSFER, "Jump if greater or equal" },
	{ "JL", CONTROL_TRANSFER, "Jump if less" },
	{ "JLE", CONTROL_TRANSFER, "Jump if less or equal" },
	{ "JMP", CONTROL_TRANSFER, "Jump" },
	{ "JNA", CONTROL_TRANSFER, "Jump if not above" },
	{ "JNAE", CONTROL_TRANSFER, "Jump if not above or equal" },
	{ "JNB", CONTROL_TRANSFER, "Jump if not below" },
	{ "JNBE", CONTROL_TRANSFER, "Jump if not below or equal" },
	{ "JNC", CONTROL_TRANSFER, "Jump if not carry" },
	{ "JNE", CONTROL_TRANSFER, "Jump if not equal" },
	{ "JNG", CONTROL_TRANSFER, "Jump if not greater" },
	{ "JNGE", CONTROL_TRANSFER, "Jump if not greater or equal" },
	{ "JNL", CONTROL_TRANSFER, "Jump if not less" },
	{ "JNLE", CONTROL_TRANSFER, "Jump if not less or equal" },
	{ "JNO", CONTROL_TRANSFER, "Jump if not overflow" },
	{ "JNP", CONTROL_TRANSFER, "Jump if not parity" },
	{ "JNS", CONTROL_TRANSFER, "Jump if not sign (non-negative)" },
	{ "JNZ", CONTROL_TRANSFER, "Jump if not zero" },
	{ "JO", CONTROL_TRANSFER, "Jump if overflow" },
	{ "JP", CONTROL_TRANSFER, "Jump if parity" },
	{ "JPE", CONTROL_TRANSFER, "Jump if parity even" },
	{ "JPO", CONTROL_TRANSFER, "Jump if parity odd" },
	{ "JS", CONTROL_TRANSFER, "Jump if sign (negative)" },
	{ "JZ", CONTROL_TRANSFER, "Jump if zero" },
	{ "LAHF", CONTROL_FLAG, "Load flags into AH register" },
	{ "LAR", SYSTEM_INSTRUCTION, "Load access rights" },
	{ "LDMXCSR", SSE_MXCSR_STATE_MANAGEMENT, "Load MXCSR register" },
	{ "LDS", SEGMENT_REGISTER, "Load far pointer using DS" },
	{ "LEA", MISC_INSTRUCTION, "Load effective address" },
	{ "LEAVE", CONTROL_TRANSFER, "High-level procedure exit" },
	{ "LES", SEGMENT_REGISTER, "Load far pointer using ES" },
	{ "LFENCE", SSE2_CACHEABILITY_CONTROL_ORDERING, "Serializes load operations" },
	{ "LFS", SEGMENT_REGISTER, "Load far pointer using FS" },
	{ "LGDT", SYSTEM_INSTRUCTION, "Load global descriptor table (GDT) register" },
	{ "LGS", SEGMENT_REGISTER, "Load far pointer using GS" },
	{ "LIDT", SYSTEM_INSTRUCTION, "Load interrupt descriptor table (IDT) register" },
	{ "LLDT", SYSTEM_INSTRUCTION, "Load local descriptor table (LDT) register" },
	{ "LMSW", SYSTEM_INSTRUCTION, "Load machine status word" },
	{ "LOADALL", SYSTEM_INSTRUCTION, "ICE. Illegal in most modes" },
	{ "LOCK", SYSTEM_INSTRUCTION, "(prefix) Lock Bus" },
	{ "LODS", STRING_INSTRUCTIONS, "Load string" },
	{ "LODSB", STRING_INSTRUCTIONS, "Load byte string" },
	{ "LODSD", STRING_INSTRUCTIONS, "Load doubleword string" },
	{ "LODSQ", MODE_64BIT, "Load qword at address (R)SI into RAX" },
	{ "LODSW", STRING_INSTRUCTIONS, "Load word string" },
	{ "LOOP", CONTROL_TRANSFER, "Loop with ECX counter" },
	{ "LOOPE", CONTROL_TRANSFER, "Loop with ECX and equal" },
	{ "LOOPNE", CONTROL_TRANSFER, "Loop with ECX and not equal" },
	{ "LOOPNZ", CONTROL_TRANSFER, "Loop with ECX and not zero" },
	{ "LOOPZ", CONTROL_TRANSFER, "Loop with ECX and zero" },
	{ "LSL", SYSTEM_INSTRUCTION, "Load segment limit" },
	{ "LSS", SEGMENT_REGISTER, "Load far pointer using SS" },
	{ "LTR", SYSTEM_INSTRUCTION, "Load task register" },
	{ "MASKMOVDQU", SSE2_CACHEABILITY_CONTROL_ORDERING, "Non-temporal store of selected bytes from an XMM register into memory" },
	{ "MASKMOVQ", SSE_CACHEABILITY_CONTROL_PREFETCH_INSTR_ORDERING, "Non-temporal store of selected bytes from an MMX register into memory" },
	{ "MAXPD", SSE2_PACKED_ARITHMETIC, "Return maximum packed double-precision floating-point values" },
	{ "MAXPS", SSE_PACKED_ARITHMETIC, "Return maximum packed single-precision floating-point values" },
	{ "MAXSD", SSE2_PACKED_ARITHMETIC, "Return maximum scalar double-precision floating-point values" },
	{ "MAXSS", SSE_PACKED_ARITHMETIC, "Return maximum scalar single-precision floating-point values" },
	{ "MFENCE", SSE2_CACHEABILITY_CONTROL_ORDERING, "Serializes load and store operations" },
	{ "MINPD", SSE2_PACKED_ARITHMETIC, "Return minimum packed double-precision floating-point values" },
	{ "MINPS", SSE_PACKED_ARITHMETIC, "Return minimum packed single-precision floating-point values" },
	{ "MINSD", SSE2_PACKED_ARITHMETIC, "Return minimum scalar double-precision floating-point values" },
	{ "MINSS", SSE_PACKED_ARITHMETIC, "Return minimum scalar single-precision floating-point values" },
	{ "MONITOR", SSE3_AGENT_SYNC, "Sets up an address range used to monitor write-back stores" },
	{ "MOV", DATA_TRANSFER, "Load and store data" }, //XXX MOV CRX is supposed to be a system instruction
	{ "MOVAPD", SSE2_DATA_MOVEMENT, "Move two aligned packed double-precision floating-point values between XMM registers or between and XMM register and memory" },
	{ "MOVAPS", SSE_DATA_TRANSFER, "Move four aligned packed single-precision floating-point values between XMM registers or between and XMM register and memory" },
	{ "MOVBE", MISC_INSTRUCTION, "Move data after swapping data bytes" },
	{ "MOVD", MMX_DATA_TRANSFER, "Move doubleword" },
	{ "MOVDDUP", SSE3_SIMD_FLOAT_LOADMOVEDUPL, "Loads/moves 64 bits (bits[63:0] if the source is a register) and returns the same 64 bits in both the lower and upper halves of the 128-bit result register; duplicates the 64 bits from the source" },
	{ "MOVDQ2Q", SSE2_128BIT_SIMD_INTEGER, "Move quadword integer from XMM to MMX registers" },
	{ "MOVDQA", SSE2_128BIT_SIMD_INTEGER, "Move aligned double quadword." },
	{ "MOVDQU", SSE2_128BIT_SIMD_INTEGER, "Move unaligned double quadword" },
	{ "MOVHLPS", SSE_DATA_TRANSFER, "Move two packed single-precision floating-point values from the high quadword of an XMM register to the low quadword of another XMM register" },
	{ "MOVHPD", SSE2_DATA_MOVEMENT, "Move high packed double-precision floating-point value to an from the high quadword of an XMM register and memory" },
	{ "MOVHPS", SSE_DATA_TRANSFER, "Move two packed single-precision floating-point values to an from the high quadword of an XMM register and memory" },
	{ "MOVLHPS", SSE_DATA_TRANSFER, "Move two packed single-precision floating-point values from the low quadword of an XMM register to the high quadword of another XMM register" },
	{ "MOVLPD", SSE2_DATA_MOVEMENT, "Move low packed single-precision floating-point value to an from the low quadword of an XMM register and memory" },
	{ "MOVLPS", SSE_DATA_TRANSFER, "Move two packed single-precision floating-point values to an from the low quadword of an XMM register and memory" },
	{ "MOVMSKPD", SSE2_DATA_MOVEMENT, "Extract sign mask from two packed double-precision floatingpoint values" },
	{ "MOVMSKPS", SSE_DATA_TRANSFER, "Extract sign mask from four packed single-precision floatingpoint values" },
	{ "MOVNTDQ", SSE2_CACHEABILITY_CONTROL_ORDERING, "Non-temporal store of double quadword from an XMM register into memory" },
	{ "MOVNTDQA", SSE4_1_STREAMING_LOAD_HINT, "Provides a non-temporal hint that can cause adjacent 16-byte items within an aligned 64-byte region (a streaming line) to be fetched and held in a small set of temporary buffers (“streaming load buffers”). Subsequent streaming loads to other aligned 16-byte items in the same streaming line may be supplied from the streaming load buffer and can improve throughput." },
	{ "MOVNTI", SSE2_CACHEABILITY_CONTROL_ORDERING, "Non-temporal store of a doubleword from a general-purpose register into memory" },
	{ "MOVNTPD", SSE2_CACHEABILITY_CONTROL_ORDERING, "Non-temporal store of two packed double-precision floatingpoint values from an XMM register into memory" },
	{ "MOVNTPS", SSE_CACHEABILITY_CONTROL_PREFETCH_INSTR_ORDERING, "Non-temporal store of four packed single-precision floatingpoint values from an XMM register into memory" },
	{ "MOVNTQ", SSE_CACHEABILITY_CONTROL_PREFETCH_INSTR_ORDERING, "Non-temporal store of quadword from an MMX register into memory" },
	{ "MOVQ", MMX_DATA_TRANSFER, "Move quadword" },
	{ "MOVQ2DQ", SSE2_128BIT_SIMD_INTEGER, "Move quadword integer from MMX to XMM registers" },
	{ "MOVS", STRING_INSTRUCTIONS, "Move string" },
	{ "MOVSB", STRING_INSTRUCTIONS, "Move byte string" },
	{ "MOVSD", STRING_INSTRUCTIONS, "Move doubleword string" },
	{ "MOVSHDUP", SSE3_SIMD_FLOAT_LOADMOVEDUPL, "Loads/moves 128 bits; duplicating the second and fourth 32-bit data elements" },
	{ "MOVSLDUP", SSE3_SIMD_FLOAT_LOADMOVEDUPL, "Loads/moves 128 bits; duplicating the first and third 32-bit data elements" },
	{ "MOVSQ", MODE_64BIT, "Move qword from address (R)SI to (R)DI" },
	{ "MOVSS", SSE_DATA_TRANSFER, "Move scalar single-precision floating-point value between XMM registers or between an XMM register and memory" },
	{ "MOVSW", STRING_INSTRUCTIONS, "Move word string" },
	{ "MOVSX", DATA_TRANSFER, "Move and sign extend" },
	{ "MOVUPD", SSE2_DATA_MOVEMENT, "Move two unaligned packed double-precision floating-point values between XMM registers or between and XMM register and memory" },
	{ "MOVUPS", SSE_DATA_TRANSFER, "Move four unaligned packed single-precision floating-point values between XMM registers or between and XMM register and memory" },
	{ "MOVZX", MODE_64BIT, "(64-bits) Move doubleword to quadword, zero-extension" },
	{ "MPSADBW", SSE4_1_SUMS_ABS_DIFF_4BYTEBLK, "Performs eight 4-byte wide Sum of Absolute Differences operations to produce eight word integers." },
	{ "MUL", BINARY_ARITHMETIC, "Unsigned multiply" },
	{ "MULPD", SSE2_PACKED_ARITHMETIC, "Multiply packed double-precision floating-point values" },
	{ "MULPS", SSE_PACKED_ARITHMETIC, "Multiply packed single-precision floating-point values" },
	{ "MULSD", SSE2_PACKED_ARITHMETIC, "Multiply scalar double-precision floating-point values" },
	{ "MULSS", SSE_PACKED_ARITHMETIC, "Multiply scalar single-precision floating-point values" },
	{ "MWAIT", SSE3_AGENT_SYNC, "Enables a logical processor to enter into an optimized state while waiting for a write-back store to the address range set up by the MONITOR instruction" },
	{ "NEG", BINARY_ARITHMETIC, "Negate" },
	{ "NOP", MISC_INSTRUCTION, "No operation" },
	{ "NOT", LOGICAL_ARITHMETIC, "Perform bitwise logical NOT" },
	{ "OR", LOGICAL_ARITHMETIC, "Perform bitwise logical OR" },
	{ "ORPD", SSE2_LOGICAL, "Perform bitwise logical OR of packed double-precision floatingpoint values" },
	{ "ORPS", SSE_LOGICAL, "Perform bitwise logical OR of packed single-precision floatingpoint values" },
	{ "OUT", IO_INSTRUCTION, "Write to a port" },
	{ "OUTS", IO_INSTRUCTION, "Output string to port" },
	{ "OUTSB", IO_INSTRUCTION, "Output byte string to port" },
	{ "OUTSD", IO_INSTRUCTION, "Output doubleword string to port" },
	{ "OUTSW", IO_INSTRUCTION, "Output word string to port" },
	{ "PABSB", SSE3_SUPPL_PACKED_ABS_VAL, "Computes the absolute value of each signed byte data element." },
	{ "PABSD", SSE3_SUPPL_PACKED_ABS_VAL, "Computes the absolute value of each signed 32-bit data element." },
	{ "PABSW", SSE3_SUPPL_PACKED_ABS_VAL, "Computes the absolute value of each signed 16-bit data element." },
	{ "PACKSSDW", MMX_CONVERSION, "Pack doublewords into words with signed saturation" },
	{ "PACKSSWB", MMX_CONVERSION, "Pack words into bytes with signed saturation" },
	{ "PACKUSDW", SSE4_1_DWORD_PACKING_WUSATURATION, "PACKUSDW packs dword to word with unsigned saturation" },
	{ "PACKUSWB", MMX_CONVERSION, "Pack words into bytes with unsigned saturation." },
	{ "PADDB", MMX_PACKED_ARITHMETIC, "Add packed byte integers" },
	{ "PADDD", MMX_PACKED_ARITHMETIC, "Add packed doubleword integers" },
	{ "PADDQ", SSE2_128BIT_SIMD_INTEGER, "Add packed quadword integers" },
	{ "PADDSB", MMX_PACKED_ARITHMETIC, "Add packed signed byte integers with signed saturation" },
	{ "PADDSW", MMX_PACKED_ARITHMETIC, "Add packed signed word integers with signed saturation" },
	{ "PADDUSB", MMX_PACKED_ARITHMETIC, "Add packed unsigned byte integers with unsigned saturation" },
	{ "PADDUSW", MMX_PACKED_ARITHMETIC, "Add packed unsigned word integers with unsigned saturation" },
	{ "PADDW", MMX_PACKED_ARITHMETIC, "Add packed word integers" },
	{ "PALIGNR", SSE3_SUPPL_PACKED_ALIGN_RIGHT, "Source operand is appended after the destination operand forming an intermediate value of twice the width of an operand. The result is extracted from the intermediate value into the destination operand by selecting the 128 bit or 64 bit value that are right-aligned to the byte offset specified by the immediate value." },
	{ "PAND", MMX_LOGICAL, "Bitwise logical AND" },
	{ "PANDN", MMX_LOGICAL, "Bitwise logical AND NOT" },
	{ "PAUSE", SSE2_CACHEABILITY_CONTROL_ORDERING, "Improves the performance of “spin-wait loops”" },
	{ "PAVGB", SSE_64BIT_SIMD_INTEGER, "Compute average of packed unsigned byte integers" },
	{ "PAVGW", SSE_64BIT_SIMD_INTEGER, "Compute average of packed unsigned word integers" },
	{ "PBLENDVB", SSE4_1_PACKED_BLENDING, "Conditionally copies specified byte elements in the source operand to the corresponding elements in the destination, using an implied mask." },
	{ "PBLENDW", SSE4_1_PACKED_BLENDING, "Conditionally copies specified word elements in the source operand to the corresponding elements in the destination, using an immediate byte control." },
	{ "PCLMULQDQ", SSE4_2_AESNIPCLMULQDQ, "Perform carryless multiplication of two 64-bit numbers" },
	{ "PCMPEQB", MMX_COMPARISON, "Compare packed bytes for equal " },
	{ "PCMPEQD", MMX_COMPARISON, "Compare packed doublewords for equal " },
	{ "PCMPEQQ", SSE4_1_PACKED_QWORD_EQUALITYCMP, "128-bit packed qword equality test" },
	{ "PCMPEQW", MMX_COMPARISON, "Compare packed words for equal " },
	{ "PCMPESTRI", SSE4_2_STRINGTEXTPROCESSING, "Packed compare explicit-length strings, return index in ECX/RCX" },
	{ "PCMPESTRM", SSE4_2_STRINGTEXTPROCESSING, "Packed compare explicit-length strings, return mask in XMM0" },
	{ "PCMPGTB", MMX_COMPARISON, "Compare packed signed byte integers for greater than" },
	{ "PCMPGTD", MMX_COMPARISON, "Compare packed signed doubleword integers for greater than" },
	{ "PCMPGTQ", SSE4_2_PACKEDCMPSIMDINT, "Performs logical compare of greater-than on packed integer quadwords." },
	{ "PCMPGTW", MMX_COMPARISON, "Compare packed signed word integers for greater than" },
	{ "PCMPISTRI", SSE4_2_STRINGTEXTPROCESSING, "Packed compare implicit-length strings, return index in ECX/RCX" },
	{ "PCMPISTRM", SSE4_2_STRINGTEXTPROCESSING, "Packed compare implicit-length strings, return mask in XMM0" },
	{ "PEXTRB", SSE4_1_INSERTION_EXTRACTION_MMX, "Extract a byte from an XMM register and insert the value into a general-purpose register or memory" },
	{ "PEXTRD", SSE4_1_INSERTION_EXTRACTION_MMX, "Extract a dword from an XMM register and insert the value into a general-purpose register or memory" },
	{ "PEXTRQ", SSE4_1_INSERTION_EXTRACTION_MMX, "Extract a qword from an XMM register and insert the value into a general-purpose register or memory" },
	{ "PEXTRW", SSE4_1_INSERTION_EXTRACTION_MMX, "Extract a word from an XMM register and insert the value into a general-purpose register or memory" },
	{ "PHADDD", SSE3_SUPPL_HORIZONTAL_ADDSUB, "Adds two adjacent, signed 32-bit integers horizontally from the source and destination operands and packs the signed 32-bit results to the destination operand." },
	{ "PHADDSW", SSE3_SUPPL_HORIZONTAL_ADDSUB, "Adds two adjacent, signed 16-bit integers horizontally from the source and destination operands and packs the signed, saturated 16-bit results to the destination operand." },
	{ "PHADDW", SSE3_SUPPL_HORIZONTAL_ADDSUB, "Adds two adjacent, signed 16-bit integers horizontally from the source and destination operands and packs the signed 16-bit results to the destination operand." },
	{ "PHMINPOSUW", SSE4_1_HORIZONTAL_SEARCH, "Finds the value and location of the minimum unsigned word from one of 8 horizontally packed unsigned words. The resulting value and location (offset within the source) are packed into the low dword of the destination XMM register." },
	{ "PHSUBD", SSE3_SUPPL_HORIZONTAL_ADDSUB, "Performs horizontal subtraction on each adjacent pair of 32-bit signed integers by subtracting the most significant doubleword from the least significant double word of each pair in the source and destination operands. The signed 32-bit results are packed and written to the destination operand." },
	{ "PHSUBSW", SSE3_SUPPL_HORIZONTAL_ADDSUB, "Performs horizontal subtraction on each adjacent pair of 16-bit signed integers by subtracting the most significant word from the least significant word of each pair in the source and destination operands. The signed, saturated 16-bit results are packed and written to the destination operand." },
	{ "PHSUBW", SSE3_SUPPL_HORIZONTAL_ADDSUB, "Performs horizontal subtraction on each adjacent pair of 16-bit signed integers by subtracting the most significant word from the least significant word of each pair in the source and destination operands. The signed 16-bit results are packed and written to the destination operand." },
	{ "PINSRB", SSE4_1_INSERTION_EXTRACTION_MMX, "Insert a byte value from a register or memory into an XMM register" },
	{ "PINSRD", SSE4_1_INSERTION_EXTRACTION_MMX, "Insert a dword value from 32-bit register or memory into an XMM register" },
	{ "PINSRQ", SSE4_1_INSERTION_EXTRACTION_MMX, "Insert a qword value from 64-bit register or memory into an XMM register" },
	{ "PINSRW", SSE_64BIT_SIMD_INTEGER, "Insert word" },
	{ "PMADDUBSW", SSE3_SUPPL_MULTIPLYADDPACKED, "Multiplies each unsigned byte value with the corresponding signed byte value to produce an intermediate, 16-bit signed integer. Each adjacent pair of 16-bit signed values are added horizontally. The signed, saturated 16-bit results are packed to the destination operand." },
	{ "PMADDWD", MMX_PACKED_ARITHMETIC, "Multiply and add packed word integers" },
	{ "PMAXSB", SSE4_1_PACKED_INT_MINMAX, "Compare packed signed byte integers." },
	{ "PMAXSD", SSE4_1_PACKED_INT_MINMAX, "Compare packed signed dword integers." },
	{ "PMAXSW", SSE_64BIT_SIMD_INTEGER, "Maximum of packed signed word integers" },
	{ "PMAXUB", SSE_64BIT_SIMD_INTEGER, "Maximum of packed unsigned byte integers" },
	{ "PMAXUD", SSE4_1_PACKED_INT_MINMAX, "Compare packed unsigned dword integers." },
	{ "PMAXUW", SSE4_1_PACKED_INT_MINMAX, "Compare packed unsigned word integers." },
	{ "PMINSB", SSE4_1_PACKED_INT_MINMAX, "Compare packed signed byte integers." },
	{ "PMINSD", SSE4_1_PACKED_INT_MINMAX, "Compare packed signed dword integers." },
	{ "PMINSW", SSE_64BIT_SIMD_INTEGER, "Minimum of packed signed word integers" },
	{ "PMINUB", SSE_64BIT_SIMD_INTEGER, "Minimum of packed unsigned byte integers" },
	{ "PMINUD", SSE4_1_PACKED_INT_MINMAX, "Compare packed unsigned dword integers." },
	{ "PMINUW", SSE4_1_PACKED_INT_MINMAX, "Compare packed unsigned word integers." },
	{ "PMOVMSKB", SSE_64BIT_SIMD_INTEGER, "Move byte mask" },
	{ "PMOVSXBD", SSE4_1_PACKED_INT_FORMAT_CONVERSION, "Sign extend the lower 8-bit integer of each packed dword element into packed signed dword integers." },
	{ "PMOVSXBQ", SSE4_1_PACKED_INT_FORMAT_CONVERSION, "Sign extend the lower 8-bit integer of each packed qword element into packed signed qword integers." },
	{ "PMOVSXBW", SSE4_1_PACKED_INT_FORMAT_CONVERSION, "Sign extend the lower 8-bit integer of each packed word element into packed signed word integers." },
	{ "PMOVSXDQ", SSE4_1_PACKED_INT_FORMAT_CONVERSION, "Sign extend the lower 32-bit integer of each packed qword element into packed signed qword integers." },
	{ "PMOVSXWD", SSE4_1_PACKED_INT_FORMAT_CONVERSION, "Sign extend the lower 16-bit integer of each packed dword element into packed signed dword integers." },
	{ "PMOVSXWQ", SSE4_1_PACKED_INT_FORMAT_CONVERSION, "Sign extend the lower 16-bit integer of each packed qword element into packed signed qword integers." },
	{ "PMOVZXBD", SSE4_1_PACKED_INT_FORMAT_CONVERSION, "Zero extend the lower 8-bit integer of each packed dword element into packed signed dword integers." },
	{ "PMOVZXBQ", SSE4_1_PACKED_INT_FORMAT_CONVERSION, "Zero extend the lower 8-bit integer of each packed qword element into packed signed qword integers." },
	{ "PMOVZXBW", SSE4_1_PACKED_INT_FORMAT_CONVERSION, "Zero extend the lower 8-bit integer of each packed word element into packed signed word integers." },
	{ "PMOVZXDQ", SSE4_1_PACKED_INT_FORMAT_CONVERSION, "Zero extend the lower 32-bit integer of each packed qword element into packed signed qword integers." },
	{ "PMOVZXWD", SSE4_1_PACKED_INT_FORMAT_CONVERSION, "Zero extend the lower 16-bit integer of each packed dword element into packed signed dword integers.." },
	{ "PMOVZXWQ", SSE4_1_PACKED_INT_FORMAT_CONVERSION, "Zero extend the lower 16-bit integer of each packed qword element into packed signed qword integers." },
	{ "PMULDQ", SSE4_1_DWORD_MULTIPLY, "Returns two 64-bit signed result of signed 32-bit integer multiplies." },
	{ "PMULHRSW", SSE3_SUPPL_PACKED_MULTIPLY_HIGHROUNDSCALE, "Multiplies vertically each signed 16-bit integer from the destination operand with the corresponding signed 16-bit integer of the source operand, producing intermediate, signed 32-bit integers. Each intermediate 32-bit integer is truncated to the 18 most significant bits. Rounding is always performed by adding 1 to the least significant bit of the 18-bit intermediate result. The final result is obtained by selecting the 16 bits immediately to the right of the most significant bit of each 18-bit intermediate result and packed to the destination operand." },
	{ "PMULHUW", SSE_64BIT_SIMD_INTEGER, "Multiply packed unsigned integers and store high result" },
	{ "PMULHW", MMX_PACKED_ARITHMETIC, "Multiply packed signed word integers and store high result" },
	{ "PMULLD", SSE4_1_DWORD_MULTIPLY, "Returns four lower 32-bits of the 64-bit results of signed 32-bit integer multiplies." },
	{ "PMULLW", MMX_PACKED_ARITHMETIC, "Multiply packed signed word integers and store low result" },
	{ "PMULUDQ", SSE2_128BIT_SIMD_INTEGER, "Multiply packed unsigned doubleword integers" },
	{ "POP", DATA_TRANSFER, "Pop off of stack" },
	{ "POPA", DATA_TRANSFER, "Pop 16bit general-purpose registers from stack" },
	{ "POPAD", DATA_TRANSFER, "Pop 32bit general-purpose registers from stack" },
	{ "POPCNT", SSE4_2_APPLICATIONACCELERATOR, "This instruction calculates of number of bits set to 1 in the second operand (source) and returns the count in the first operand (a destination register)" },
	{ "POPF", CONTROL_FLAG, "Pop EFLAGS from stack" },
	{ "POPFD", CONTROL_FLAG, "Pop EFLAGS from stack" },
	{ "POR", MMX_LOGICAL, "Bitwise logical OR" },
	{ "PREFETCH0", SSE_CACHEABILITY_CONTROL_PREFETCH_INSTR_ORDERING, "Load 32 or more of bytes from memory to T0 (temporal data) into all levels of cache hierarchy" },
	{ "PREFETCH1", SSE_CACHEABILITY_CONTROL_PREFETCH_INSTR_ORDERING, "Load 32 or more of bytes from memory to T1 (temporal data with respect to first level cache) into level 2 cache or higher in the cache hierarchy" },
	{ "PREFETCH2", SSE_CACHEABILITY_CONTROL_PREFETCH_INSTR_ORDERING, "Load 32 or more of bytes from memory to T1 (temporal data with respect to second level cache) into level 2 cache or higher in the cache hierarchy" },
	{ "PREFETCHNTA", SSE_CACHEABILITY_CONTROL_PREFETCH_INSTR_ORDERING, "Load 32 or more of bytes from memory into a non-temporal cache structure and into a location close to the processor, minimizing cache pollution" },
	{ "PSADBW", SSE_64BIT_SIMD_INTEGER, "Compute sum of absolute differences" },
	{ "PSHUFB", SSE3_SUPPL_PACKED_SHUFFLE_BYTES, "Permutes each byte in place, according to a shuffle control mask. The least significant three or four bits of each shuffle control byte of the control mask form the shuffle index. The shuffle mask is unaffected. If the most significant bit (bit 7) of a shuffle control byte is set, the constant zero is written in the result byte." },
	{ "PSHUFD", SSE2_128BIT_SIMD_INTEGER, "Shuffle packed doublewords" },
	{ "PSHUFHW", SSE2_128BIT_SIMD_INTEGER, "Shuffle packed high words" },
	{ "PSHUFLW", SSE2_128BIT_SIMD_INTEGER, "Shuffle packed low words" },
	{ "PSHUFW", SSE_64BIT_SIMD_INTEGER, "Shuffle packed integer word in MMX register" },
	{ "PSIGNB", SSE3_SUPPL_PACKED_SIGN, "Negates each signed integer element of the destination operand if the sign of the corresponding data element in the source operand is less than zero." },
	{ "PSLLD", MMX_SHIFT_ROTATE, "Shift packed doublewords left logical" },
	{ "PSLLDQ", SSE2_128BIT_SIMD_INTEGER, "Shift double quadword left logical" },
	{ "PSLLQ", MMX_SHIFT_ROTATE, "Shift packed quadword left logical" },
	{ "PSLLW", MMX_SHIFT_ROTATE, "Shift packed words left logical" },
	{ "PSRAD", MMX_SHIFT_ROTATE, "Shift packed doublewords right arithmetic" },
	{ "PSRAW", MMX_SHIFT_ROTATE, "Shift packed words right arithmetic" },
	{ "PSRLD", MMX_SHIFT_ROTATE, "Shift packed doublewords right logical" },
	{ "PSRLDQ", SSE2_128BIT_SIMD_INTEGER, "Shift double quadword right logical" },
	{ "PSRLQ", MMX_SHIFT_ROTATE, "Shift packed quadword right logical" },
	{ "PSRLW", MMX_SHIFT_ROTATE, "Shift packed words right logical" },
	{ "PSUBB", MMX_PACKED_ARITHMETIC, "Subtract packed byte integers" },
	{ "PSUBD", MMX_PACKED_ARITHMETIC, "Subtract packed doubleword integers" },
	{ "PSUBQ", SSE2_128BIT_SIMD_INTEGER, "Subtract packed quadword integers" },
	{ "PSUBSB", MMX_PACKED_ARITHMETIC, "Subtract packed signed byte integers with signed saturation" },
	{ "PSUBSW", MMX_PACKED_ARITHMETIC, "Subtract packed signed word integers with signed saturation" },
	{ "PSUBUSB", MMX_PACKED_ARITHMETIC, "Subtract packed unsigned byte integers with unsigned saturation" },
	{ "PSUBUSW", MMX_PACKED_ARITHMETIC, "Subtract packed unsigned word integers with unsigned saturation" },
	{ "PSUBW", MMX_PACKED_ARITHMETIC, "Subtract packed word integers" },
	{ "PTEST", SSE4_1_PACKED_TEST, "Performs a logical AND between the destination with this mask and sets the ZF flag if the result is zero. The CF flag (zero for TEST) is set if the inverted mask AND’d with the destination is all zero" },
	{ "PUNPCKHBW", MMX_CONVERSION, "Unpack high-order bytes" },
	{ "PUNPCKHDQ", MMX_CONVERSION, "Unpack high-order doublewords" },
	{ "PUNPCKHQDQ", SSE2_128BIT_SIMD_INTEGER, "Unpack high quadwords" },
	{ "PUNPCKHWD", MMX_CONVERSION, "Unpack high-order words" },
	{ "PUNPCKLBW", MMX_CONVERSION, "Unpack low-order bytes" },
	{ "PUNPCKLDQ", MMX_CONVERSION, "Unpack low-order doublewords" },
	{ "PUNPCKLQDQ", SSE2_128BIT_SIMD_INTEGER, "Unpack low quadwords" },
	{ "PUNPCKLWD", MMX_CONVERSION, "Unpack low-order words" },
	{ "PUSH", DATA_TRANSFER, "Push onto stack" },
	{ "PUSHA", DATA_TRANSFER, "Push 16bit general-purpose registers onto stack" },
	{ "PUSHAD", DATA_TRANSFER, "Push 32bit general-purpose registers onto stack" },
	{ "PUSHF", CONTROL_FLAG, "Push EFLAGS onto stack" },
	{ "PUSHFD", CONTROL_FLAG, "Push EFLAGS onto stack" },
	{ "PXOR", MMX_LOGICAL, "Bitwise logical exclusive OR" },
	{ "RCL", SHIFT_ROTATE, "Rotate through carry left" },
	{ "RCPPS", SSE_PACKED_ARITHMETIC, "Compute reciprocals of packed single-precision floating-point values" },
	{ "RCPSS", SSE_PACKED_ARITHMETIC, "Compute reciprocal of scalar single-precision floating-point values" },
	{ "RCR", SHIFT_ROTATE, "Rotate through carry right" },
	{ "RDFSBASE", SYSTEM_INSTRUCTION, "Reads from FS base address at any privilege level" },
	{ "RDGSBASE", SYSTEM_INSTRUCTION, "Reads from GS base address at any privilege level" },
	{ "RDMSR", SYSTEM_INSTRUCTION, "Read model-specific register" },
	{ "RDPMC", SYSTEM_INSTRUCTION, "Read performance monitoring counters" },
	{ "RDRAND", RANDOM_GENERATOR, "retrieves a random number generated from hardware." },
	{ "RDTSC", SYSTEM_INSTRUCTION, "Read time stamp counter" },
	{ "RDTSCP", SYSTEM_INSTRUCTION, "Read time stamp counter and processor ID" },
	{ "REP", STRING_INSTRUCTIONS, "Repeat while ECX not zero" },
	{ "REPE", STRING_INSTRUCTIONS, "Repeat while equal" },
	{ "REPNE", STRING_INSTRUCTIONS, "Repeat while not equal" },
	{ "REPNZ", STRING_INSTRUCTIONS, "Repeat while not zero" },
	{ "REPZ", STRING_INSTRUCTIONS, "Repeat while zero" },
	{ "RET", CONTROL_TRANSFER, "Return" },
	{ "RETF", CONTROL_TRANSFER, "Far Return" },
	{ "ROL", SHIFT_ROTATE, "Rotate left" },
	{ "ROR", SHIFT_ROTATE, "Rotate right" },
	{ "ROUNDPD", SSE4_1_FP_ROUNDSELECTROUND, "Round packed double precision floating-point values into integer values and return rounded floating-point values." },
	{ "ROUNDPS", SSE4_1_FP_ROUNDSELECTROUND, "Round packed single precision floating-point values into integer values and return rounded floating-point values." },
	{ "ROUNDSD", SSE4_1_FP_ROUNDSELECTROUND, "Round the low packed double precision floating-point value into an integer value and return a rounded floating-point value." },
	{ "ROUNDSS", SSE4_1_FP_ROUNDSELECTROUND, "Round the low packed single precision floating-point value into an integer value and return a rounded floating-point value." },
	{ "RSM", SYSTEM_INSTRUCTION, "Return from system management mode (SMM)" },
	{ "RSQRTPS", SSE_PACKED_ARITHMETIC, "Compute reciprocals of square roots of packed single-precision floating-point values" },
	{ "RSQRTSS", SSE_PACKED_ARITHMETIC, "Compute reciprocal of square root of scalar single-precision floating-point values" },
	{ "SAHF", CONTROL_FLAG, "Store AH register into flags" },
	{ "SAL", SHIFT_ROTATE, "Shift arithmetic left" },
	{ "SALC", CONTROL_FLAG, "Set carry flag in AL" },
	{ "SAR", SHIFT_ROTATE, "Shift arithmetic right" },
	{ "SBB", BINARY_ARITHMETIC, "Subtract with borrow" },
	{ "SCAS", STRING_INSTRUCTIONS, "Scan string" },
	{ "SCASB", STRING_INSTRUCTIONS, "Scan byte string" },
	{ "SCASD", STRING_INSTRUCTIONS, "Scan doubleword string" },
	{ "SCASW", STRING_INSTRUCTIONS, "Scan word string" },
	{ "SETA", BIT_BYTE, "Set byte if above" },
	{ "SETAE", BIT_BYTE, "Set byte if above or equal" },
	{ "SETB", BIT_BYTE, "Set byte if below" },
	{ "SETBE", BIT_BYTE, "Set byte if below or equal" },
	{ "SETC", BIT_BYTE, "Set byte if carry" },
	{ "SETE", BIT_BYTE, "Set byte if equal" },
	{ "SETG", BIT_BYTE, "Set byte if greater" },
	{ "SETGE", BIT_BYTE, "Set byte if greater or equal" },
	{ "SETL", BIT_BYTE, "Set byte if less" },
	{ "SETLE", BIT_BYTE, "Set byte if less or equal" },
	{ "SETNA", BIT_BYTE, "Set byte if not above" },
	{ "SETNAE", BIT_BYTE, "Set byte if not above or equal" },
	{ "SETNB", BIT_BYTE, "Set byte if not below" },
	{ "SETNBE", BIT_BYTE, "Set byte if not below or equal" },
	{ "SETNC", BIT_BYTE, "Set byte if not carry" },
	{ "SETNE", BIT_BYTE, "Set byte if not equal" },
	{ "SETNG", BIT_BYTE, "Set byte if not greater" },
	{ "SETNGE", BIT_BYTE, "Set byte if not greater or equal" },
	{ "SETNL", BIT_BYTE, "Set byte if not less" },
	{ "SETNLE", BIT_BYTE, "Set byte if not less or equal" },
	{ "SETNO", BIT_BYTE, "Set byte if not overflow" },
	{ "SETNP", BIT_BYTE, "Set byte if not parity" },
	{ "SETNS", BIT_BYTE, "Set byte if not sign (non-negative)" },
	{ "SETNZ", BIT_BYTE, "Set byte if not zero" },
	{ "SETO", BIT_BYTE, "Set byte if overflow" },
	{ "SETP", BIT_BYTE, "Set byte if parity" },
	{ "SETPE", BIT_BYTE, "Set byte if parity even" },
	{ "SETPO", BIT_BYTE, "Set byte if parity odd" },
	{ "SETS", BIT_BYTE, "Set byte if sign (negative)" },
	{ "SETZ", BIT_BYTE, "Set byte if zero" },
	{ "SFENCE", SSE_CACHEABILITY_CONTROL_PREFETCH_INSTR_ORDERING, "Serializes store operations" },
	{ "SGDT", SYSTEM_INSTRUCTION, "Store global descriptor table (GDT) register" },
	{ "SHL", SHIFT_ROTATE, "Shift logical left" },
	{ "SHLD", SHIFT_ROTATE, "Shift left double" },
	{ "SHR", SHIFT_ROTATE, "Shift logical right" },
	{ "SHRD", SHIFT_ROTATE, "Shift right double" },
	{ "SHUFPD", SSE2_SHUFFLE_UNPACK, "Shuffles values in packed double-precision floating-point operands" },
	{ "SHUFPS", SSE_SHUFFLE_UNPACK, "Shuffles values in packed single-precision floating-point operands" },
	{ "SIDT", SYSTEM_INSTRUCTION, "Store interrupt descriptor table (IDT) register" },
	{ "SLDT", SYSTEM_INSTRUCTION, "Store local descriptor table (LDT) register" },
	{ "SMSW", SYSTEM_INSTRUCTION, "Store machine status word" },
	{ "SQRTPD", SSE2_PACKED_ARITHMETIC, "Compute packed square roots of packed double-precision floating-point values" },
	{ "SQRTPS", SSE_PACKED_ARITHMETIC, "Compute square roots of packed single-precision floating-point values" },
	{ "SQRTSD", SSE2_PACKED_ARITHMETIC, "Compute scalar square root of scalar double-precision floatingpoint values" },
	{ "SQRTSS", SSE_PACKED_ARITHMETIC, "Compute square root of scalar single-precision floating-point values" },
	{ "STC", CONTROL_FLAG, "Set carry flag" },
	{ "STD", CONTROL_FLAG, "Set direction flag" },
	{ "STI", CONTROL_FLAG, "Set interrupt flag" },
	{ "STMXCSR", SSE_MXCSR_STATE_MANAGEMENT, "Save MXCSR register state" },
	{ "STOS", STRING_INSTRUCTIONS, "Store string" },
	{ "STOSB", STRING_INSTRUCTIONS, "Store byte string" },
	{ "STOSD", STRING_INSTRUCTIONS, "Store doubleword string" },
	{ "STOSQ", MODE_64BIT, "Store RAX at address RDI" },
	{ "STOSW", STRING_INSTRUCTIONS, "Store word string" },
	{ "STR", SYSTEM_INSTRUCTION, "Store task register" },
	{ "SUB", BINARY_ARITHMETIC, "Subtract" },
	{ "SUBPD", SSE2_PACKED_ARITHMETIC, "Subtract scalar double-precision floating-point values" },
	{ "SUBPS", SSE_PACKED_ARITHMETIC, "Subtract packed single-precision floating-point values" },
	{ "SUBSD", SSE2_PACKED_ARITHMETIC, "Subtract scalar double-precision floating-point values" },
	{ "SUBSS", SSE_PACKED_ARITHMETIC, "Subtract scalar single-precision floating-point values" },
	{ "SWAPGS", MODE_64BIT, "Exchanges current GS base register value with value in MSR address C0000102H" },
	{ "SYSCALL", MODE_64BIT, "Fast call to privilege level 0 system procedures" },
	{ "SYSENTER", SYSTEM_INSTRUCTION, "Fast System Call, transfers to a flat protected mode kernel at CPL = 0" },
	{ "SYSEXIT", SYSTEM_INSTRUCTION, "Fast System Call, transfers to a flat protected mode kernel at CPL = 3" },
	{ "SYSRET", MODE_64BIT, "Return from fast system call" },
	{ "TEST", BIT_BYTE, "Logical compare" },
	{ "UCOMISD", SSE2_COMPARE, "Perform unordered comparison of scalar double-precision floating-point values and set flags in EFLAGS register." },
	{ "UCOMISS", SSE_COMPARISON, "Perform unordered comparison of scalar single-precision floating-point values and set flags in EFLAGS register" },
	{ "UD2", MISC_INSTRUCTION, "Undefined instruction" },
	{ "UNPCKHPD", SSE2_SHUFFLE_UNPACK, "Unpacks and interleaves the high values from two packed double-precision floating-point operands" },
	{ "UNPCKHPS", SSE_SHUFFLE_UNPACK, "Unpacks and interleaves the two high-order values from two single-precision floating-point operands" },
	{ "UNPCKLPD", SSE2_SHUFFLE_UNPACK, "Unpacks and interleaves the low values from two packed double-precision floating-point operands" },
	{ "UNPCKLPS", SSE_SHUFFLE_UNPACK, "Unpacks and interleaves the two low-order values from two single-precision floating-point operands" },
	{ "VCVTPH2PS", AVX_16BIT_FP_CONVERSION, "Convert eight/four data element containing 16-bit floating-point data into eight/four single-precision floating-point data." },
	{ "VCVTPS2PH", AVX_16BIT_FP_CONVERSION, "Convert eight/four data element containing single-precision floating-point data into eight/four 16-bit floating-point data." },
	{ "VERR", SYSTEM_INSTRUCTION, "Verify segment for reading" },
	{ "VERW", SYSTEM_INSTRUCTION, "Verify segment for writing" },
	{ "VMCALL", VM_EXTENSIONS, "Allows a guest in VMX non-root operation to call the VMM for service. A VM exit occurs, transferring control to the VMM." },
	{ "VMCLEAR", VM_EXTENSIONS, "Takes a single 64-bit operand in memory. The instruction sets the launch state of the VMCS referenced by the operand to “clear”, renders that VMCS inactive, and ensures that data for the VMCS have been written to the VMCS-data area in the referenced VMCS region." },
	{ "VMFUNC", VM_EXTENSIONS, "This instruction allows software in VMX non-root operation to invoke a VM function, which is processor functionality enabled and configured by software in VMX root operation. No VM exit occurs." },
	{ "VMLAUNCH", VM_EXTENSIONS, "Launches a virtual machine managed by the VMCS. A VM entry occurs, transferring control to the VM." },
	{ "VMPTRLD", VM_EXTENSIONS, "Takes a single 64-bit source operand in memory. It makes the referenced VMCS active and current." },
	{ "VMPTRST", VM_EXTENSIONS, "Takes a single 64-bit destination operand that is in memory. Current-VMCS pointer is stored into the destination operand." },
	{ "VMREAD", VM_EXTENSIONS, "Reads a component from the VMCS (the encoding of that field is given in a register operand) and stores it into a destination operand." },
	{ "VMRESUME", VM_EXTENSIONS, "Resumes a virtual machine managed by the VMCS. A VM entry occurs, transferring control to the VM." },
	{ "VMWRITE", VM_EXTENSIONS, "Writes a component to the VMCS (the encoding of that field is given in a register operand) from a source operand. The behavior of the VMX management instructions is summarized below:" },
	{ "VMXOFF", VM_EXTENSIONS, "Causes the processor to leave VMX operation." },
	{ "VMXON", VM_EXTENSIONS, "Takes a single 64-bit source operand in memory. It causes a logical processor to enter VMX root operation and to use the memory referenced by the operand to support VMX operation." },
	{ "WAIT", FPU_CONTROL, "Wait for FPU" },
	{ "WBINVD", SYSTEM_INSTRUCTION, "Invalidate cache, with writeback" },
	{ "WRFSBASE", SYSTEM_INSTRUCTION, "Writes to FS base address at any privilege level" },
	{ "WRGSBASE", SYSTEM_INSTRUCTION, "Writes to GS base address at any privilege level" },
	{ "WRMSR", SYSTEM_INSTRUCTION, "Write model-specific register" },
	{ "XADD", DATA_TRANSFER, "Exchange and add" },
	{ "XCHG", DATA_TRANSFER, "Exchange" },
	{ "XGETBV", SYSTEM_INSTRUCTION, "Reads the state of an extended control register" },
	{ "XLAT", MISC_INSTRUCTION, "Table lookup translation" },
	{ "XLATB", MISC_INSTRUCTION, "Table lookup translation" },
	{ "XOR", LOGICAL_ARITHMETIC, "Perform bitwise logical exclusive OR" },
	{ "XORPD", SSE2_LOGICAL, "Perform bitwise logical XOR of packed double-precision floatingpoint values" },
	{ "XORPS", SSE_LOGICAL, "Perform bitwise logical XOR of packed single-precision floatingpoint values" },
	{ "XRSTOR", SYSTEM_INSTRUCTION, "Restore processor extended states from memory" },
	{ "XSAVE", SYSTEM_INSTRUCTION, "Save processor extended states to memory" },
	{ "XSAVEOPT", SYSTEM_INSTRUCTION, "Save processor extended states to memory, optimized" },
	{ "XSETBV", SYSTEM_INSTRUCTION, "Writes the state of an extended control register" },
	{ "FMMS", AMD_3D, "Clear MMX state after MMX instructions" },
	{ "CLAC", 0, "????" },
	{ "STAC", 0, "????" },
	{ "XEND", 0, "????" },
	{ "XTEST", 0, "????" }
};
